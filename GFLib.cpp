
#include "GFLib.h"
#include "GF2Extension.h"
#include "SubField.h"
#include <memory>
#include <utility>

///////////////////////////////////////////////////////////////////////////////
struct GCDRes
{
	int afactor;
	int bfactor;
	int gcd;
};

GCDRes ExtendedEucliedean(int a, int b)
{
	assert(a != 0 && b != 0);
	int s = 0, old_s = 1;
	int t = 1, old_t = 0;
	int r = b, old_r = a;

	int prov, quotient;
#define PA(r, old_r, quotient)			\
		prov = r;						\
		r = old_r - quotient * prov;	\
		old_r = prov;

	while (r != 0)
	{
		quotient = old_r / r;
		PA(r, old_r, quotient)
		PA(s, old_s, quotient)
		PA(t, old_t, quotient)
	}
#undef PA

	GCDRes res;
	res.afactor = old_s;
	res.bfactor = old_t;
	res.gcd = old_r;

	assert(res.afactor * a + res.bfactor * b == res.gcd);

	return res;
}
void AbelienianDecomp(const int val, int ndim, const int *sizes, int *pres)
{
	for (int i = 0; i < ndim; i++)
		pres[i] = val % sizes[i];

	return;
}

int _AbelienianReverse(int s1, int s2, int m1, int m2)
{

	int del = m2 - m1;

	auto r = ExtendedEucliedean(s1, s2);
	assert(r.gcd == 1);

	int res;
	res = r.afactor * s1 * del + m1;
	
	auto p = s1 * s2;

	res = (res + p * s2) % p;
	
	assert(res >= 0 && res < s1 * s2);
	assert(res % s1 == m1);
	assert(res % s2 == m2);

	return res;
}

int AbelienianReverse(int ndim, const int *powers, const int *mods)
{
	assert(ndim >= 2);
	int cp = powers[0];
	int cm = mods[0];

	for (int i = 1; i < ndim; i++)
	{
		cm = _AbelienianReverse(cp, powers[i], cm, mods[i]);
		cp *= powers[i];
	}
	return cm;
}

void TestDecomp(const int *powers)
{
	int prod = 1;
	int np;
	for (np = 0; powers[np]; np++)
	{
		prod *= powers[np];
	}

	vector<int> mods;
	mods.resize(np);
	for (int i = 0; i < prod; i++)
	{
		AbelienianDecomp(i, np, powers, mods.data());
		int rev = AbelienianReverse(np, powers, mods.data());
		assert(i == rev);
	}
}

void GCDExp()
{
	int pi[] = { 8, 9, 5, 0 };
	TestDecomp(pi);

	//int pi1[] = { 64, 83 * 83, 27, 5, 0 };
	//TestDecomp(pi1);


	cout << _AbelienianReverse(4, 5, 3, 4);

}
///////////////////////////////////////////////////////////////////////////////
int main(int argc, char* argv[])
{
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);

	GCDExp();

	TestConvert();
	
/*	{
		GF2Extension ext(7);
		ext.testClass();

		cout << "GF(4) with poly " << ext.format(ext.poly()) << "\n";
		cout << ext.makeMultiplicationTable();
	}
	*/
	{
		GF2Extension ext(31);
		ext.testClass();

		cout << "GF("<< ext.size() << ") with poly " << ext.format(ext.poly()) << "\n";
		cout << ext.makeMultiplicationTable();
		cout << ext.makeGeneratorList();
		cout << ext.makeGaloisData();

		for (int p = 2; p <= ext.size(); p *= 2)
		{
			for (uint i = 0; i < ext.size(); i++)
			{
				ext.normFromGalois(i, p);
			}
		}


		/*
		cout << "Subfields generated by a single generator:\n";
		vector<unique_ptr<Subfield>> afields;
		for (uint i = 1; i < ext.size(); i++)
		{
			Subfield *psf = new Subfield(&ext);
			psf->addElement(i);
			psf->generateField();

			bool found = false;
			for (size_t j = 0; j < afields.size(); j++)
			{
				if (afields[j]->isIdentical(psf))
				{ 
					found = true;
					break;
				}
			}
			if (!found)
				afields.emplace_back(psf);
			else
				delete psf;

		}

		for (size_t j = 0; j < afields.size(); j++)
		{
			afields[j]->dump();

		}
		*/
	}


	return 0;
}

